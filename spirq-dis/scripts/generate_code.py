import json
from typing import Any, Dict, List

with open('spirv.core.grammar.json', 'r') as f:
    J = json.load(f)

magic_number = J['magic_number']
major_version = J['major_version']
minor_version = J['minor_version']
revision = J['revision']

instruction_printing_class = J['instruction_printing_class']
instructions = J['instructions']
operand_kinds = J['operand_kinds']
operand_kinds = {operand_kind['kind']: operand_kind for operand_kind in operand_kinds}


def make_header() -> List[str]:
    out = [
        "// Path: src/spirv_core_grammar.rs",
        "// This file is generated by generate_code.py",
        "#![allow(non_camel_case_types)]",
        "#![allow(non_snake_case)]",
        "use bitflags::bitflags;",
        "use num_traits::FromPrimitive;",
        "",
        f"pub const MAGIC_NUMBER: u32 = {magic_number};",
        f"pub const MAJOR_VERSION: u16 = {major_version};",
        f"pub const MINOR_VERSION: u16 = {minor_version};",
        f"pub const REVISION: u32 = {revision};",
        "",
        "pub type Result<T> = anyhow::Result<T>;",
        "",
        "pub struct Instruction {",
        "    pub opcode: u16,",
        "    pub operands: Vec<Operand>,",
        "}",
    ]
    return out


def make_type_defs() -> List[str]:
    out = [
    ]
    return out


def as_name(x: str) -> str:
    if x[0].isdigit():
        return f"_{x}"
    return x


def make_operand_kind_typedef_BitEnum(kind: str, operand_kind: Any) -> List[str]:
    out = []
    enumerants = operand_kind['enumerants']
    out += [
        f"#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]",
        f"pub struct Operand_{kind} {{",
        f"    pub value: spirv::{as_name(kind)},",
        f"}}",
    ]
    out += [
        f"impl Operand_{as_name(kind)} {{",
        "    pub fn parse(x: &mut impl Iterator<Item=u32>) -> Option<Self> {",
        "        let data = x.next()?;",
        f"        let value = spirv::{as_name(kind)}::from_bits_truncate(data);",
        "        Some(Self { value })",
        "    }",
        "}",
        "",
    ]
    return out

def make_operand_kind_typedef_ValueEnum(kind: str, operand_kind: Any) -> List[str]:
    out = []
    enumerants = operand_kind['enumerants']
    out += [
        f"#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]",
        f"pub struct Operand_{as_name(kind)} {{",
        f"    pub value: spirv::{as_name(kind)},",
        f"}}",
    ]
    out += [
        f"impl Operand_{as_name(kind)} {{",
        "    pub fn parse(x: &mut impl Iterator<Item=u32>) -> Option<Self> {",
        "        let data = x.next()?;",
        f"        let value = spirv::{as_name(kind)}::from_u32(data)?;",
        "        Some(Self { value })",
        "    }",
        "}",
    ]
    return out

def make_operand_kind_typedef_Id(kind: str, operand_kind: Any) -> List[str]:
    out = []
    out += [
        f"#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]",
        f"pub struct Operand_{as_name(kind)} {{",
        f"    pub id: u32,",
        f"}}",
    ]
    out += [
        f"impl Operand_{as_name(kind)} {{",
        f"    pub fn parse(x: &mut impl Iterator<Item=u32>) -> Option<Self> {{",
        f"        let id = x.next()?;",
        f"        Some(Self {{ id }})",
        f"    }}",
        f"}}",
    ]
    return out

def make_operand_kind_typedef_Literal(kind: str, operand_kind: Any) -> List[str]:
    out = []
    out += [
        f"#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]",
        f"pub struct Operand_{as_name(kind)} {{",
        f"    pub value: Vec<u32>,",
        f"}}",
    ]
    if kind == 'LiteralContextDependentNumber':
        out += [
            f"impl Operand_{as_name(kind)} {{",
            f"    pub fn parse(x: &mut impl Iterator<Item=u32>) -> Option<Self> {{",
            f"        let mut value = Vec::new();",
            f"        while let Some(data) = x.next() {{",
            f"            value.push(data);",
            f"        }}",
            f"        Some(Self {{ value }})",
            f"    }}",
            f"}}",
        ]
    else:
        out += [
            f"impl Operand_{as_name(kind)} {{",
            f"    pub fn parse(x: &mut impl Iterator<Item=u32>) -> Option<Self> {{",
            f"        if let Some(data) = x.next() {{",
            f"            Some(Self {{ value: vec![data] }})",
            f"        }} else {{",
            f"            None",
            f"        }}",
            f"    }}",
            f"}}",
        ]
    return out

def make_operand_kind_typedef_Composite(kind: str, operand_kind: Any) -> List[str]:
    out = []
    operand_kind = operand_kinds[kind]
    bases = operand_kind['bases']
    out += [
        f"#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]",
        f"pub struct Operand_{as_name(kind)} {{",
    ]
    for i, base in enumerate(bases):
        out += [
            f"    pub _{i}: Operand_{base},",
        ]
    out += [
        f"}}",
    ]
    out += [
        f"impl Operand_{as_name(kind)} {{",
        f"    pub fn parse(x: &mut impl Iterator<Item=u32>) -> Option<Self> {{",
        f"        Some(Self {{",
    ]
    for i, base in enumerate(bases):
        out += [
           f"            _{i}: Operand_{base}::parse(x)?,",
        ]
    out += [
        f"        }})",
        f"    }}",
        f"}}",
    ]
    return out

def make_operand_kind_typedef(kind: str, operand_kinds: Dict[str, Any]) -> List[str]:
    out = []
    operand_kind = operand_kinds[kind]
    kind = operand_kind['kind']
    category = operand_kind['category']
    if category == 'BitEnum':
        out += make_operand_kind_typedef_BitEnum(kind, operand_kind)
    elif category == 'ValueEnum':
        out += make_operand_kind_typedef_ValueEnum(kind, operand_kind)
    elif category == 'Id':
        out += make_operand_kind_typedef_Id(kind, operand_kind)
    elif category == 'Literal':
        out += make_operand_kind_typedef_Literal(kind, operand_kind)
    elif category == 'Composite':
        out += make_operand_kind_typedef_Composite(kind, operand_kind)
    else:
        assert False, f"Unknown category: {category}"

    out += [
        f"impl Into<Operand> for Operand_{as_name(kind)} {{",
        f"    fn into(self) -> Operand {{",
        f"        Operand::{kind}(self)",
        f"    }}",
        f"}}",
        "",
    ]

    return out

def make_operand_kind_section(operand_kinds: Dict[str, Any]) -> List[str]:
    out = []

    for kind in operand_kinds:
        out += make_operand_kind_typedef(kind, operand_kinds)

    out += [
        "enum Operand {",
    ]
    for kind in operand_kinds:
        out += [f"    {kind}(Operand_{kind}),"]
    out += [
        "}",
        "",
    ]
    return out

def make_parse_operand_section(operand_kinds: Dict[str, Any]) -> List[str]:
    out = []
    for operand in operand_kinds.values():
        kind = operand['kind']
        quantifier = operand['quantifier'] if 'quantifier' in operand else None
        out += [f"fn parse_{kind}<'a>(operands: &'a mut impl Iterator<Item=u32>, out: &mut Vec<Operand>) -> Operand<'a> {{"]
        print(kind, quantifier)
        if quantifier is None:
            out += [
                "    let data: u32 = operands.next().unwrap();",
                f"    out.push(Operand::{kind}(Operand_{kind}::parse(data)));",
            ]
        else:
            print(f"{kind} is quantified with {quantifier} but parameter quantification is not allowed yet.")
            continue
        out += ["}"]
    return out

def parse_instruction_operand(operand: Any) -> List[str]:
    out = []
    kind = operand['kind']
    quantifier = operand['quantifier'] if 'quantifier' in operand else None
    if quantifier is None:
        out += [
            "    if operands.peek().is_some() {",
            f"        out_operands.push(Operand_{kind}::parse(data)?.into());",
            "    } else {",
            f"        anyhow::bail!(\"Expected operand {kind} but none found\");",
            "    }",
        ]
    elif quantifier == '?':
        out += [
            "    if operands.peek().is_some() {",
            f"        out_operands.push(Operand_{kind}::parse(data)?.into());",
            "    }",
        ]
    elif quantifier == '*':
        out += [
            "    while operands.peek().is_some() {",
            f"        out_operands.push(Operand_{kind}::parse(data)?.into());",
            "    }",
        ]
    else:
        print(f"{kind} is quantified with {quantifier} but parameter quantification is not allowed yet.")

    return out

def make_parse_instruction(instruction: Any) -> List[str]:
    out = []
    opname = instruction['opname']
    clazz = instruction['class']
    opcode = instruction['opcode']
    operands = instruction['operands'] if 'operands' in instruction else []

    out += [
        f"fn parse_{opname}<'a>(operands: &[u32], out_operands: &mut Vec<Operand>) -> Result<()> {{",
        f"    let mut data = operands.iter().peek().copied();",
    ]
    for operand in operands:
        out += parse_instruction_operand(operand)
    out += [
        "    Ok(())",
        "}",
    ]

    return out

def make_parse_instructions(instructions: Any) -> List[str]:
    out = []
    for instruction in instructions:
        out += make_parse_instruction(instruction)

    out += [
        "fn parse_instruction(opcode: u16, operands: &[u32]) -> Result<Instruction> {",
        "    let out_operands = Vec::new();",
        "    match opcode {"
    ]
    for instruction in instructions:
        opname = instruction['opname']
        opcode = instruction['opcode']
        out += [
            f"        {opcode} => parse_{opname}(operands, &mut out_operands),",
        ]
    out += [
        f"        _ => anyhow::bail!(\"Unknown opcode: {{}}\", opcode),",
        "    }",
        "    let out = Instruction {",
        "        opcode,",
        "        operands: Vec::new(),",
        "    };",
        "    Ok(Instruction {",
        "        opcode,",
        "        operands: out_operands,",
        "    })",
        "}",
        "",
    ]

    out += [
        "pub fn parse(words: &[u32]) -> Result<Vec<Instruction>> {",
        "    let mut out = Vec::new();",
        "    let mut words = words.iter();",
        "    while let Some(opcode) = words.next() {",
        "        let word_count = (opcode >> 16) & 0xffff;",
        "        let opcode = opcode & 0xffff;",
        "        let mut operands = Vec::new();",
        "        for _ in 0..word_count {",
        "            operands.push(words.next().copied().unwrap());",
        "        }",
        "        out.push(parse_instruction(opcode, &operands)?);",
        "    }",
        "    Ok(out)",
        "}",
        "",
    ]

    return out


lines = []
lines += make_header()
lines += make_type_defs()
lines += make_operand_kind_section(operand_kinds)
#lines += make_parse_operand_section(operand_kinds)
lines += make_parse_instructions(instructions)

lines = '\n'.join(lines)

with open('src/spirv_core_grammar.rs', 'w') as f:
    f.write(lines)
